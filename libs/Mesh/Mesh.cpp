#include "interface/Mesh/Mesh.h"

#include <fstream>
#include <sstream>

namespace plasmatic {

Mesh::Mesh(const std::filesystem::path &filename) : _nodes(std::make_shared<std::vector<Coord>>()) {
    Log::Info("Reading mesh from file '{}'", filename.string());
    std::ifstream in(filename);

    std::string line;

    while (std::getline(in, line)) {
        if (line == "$Nodes") {
            Integer num_entity_blocks = 0;
            Integer num_nodes = 0;

            {
                std::getline(in, line);
                std::stringstream ss(line);
                ss >> num_entity_blocks >> num_nodes;
            }

            for (Integer ii = 0; ii < num_entity_blocks; ++ii) {
                Integer entity_dim = 0;
                Integer entity_tag = 0;
                Integer parametric = 0;
                Integer nodes_in_block = 0;
                {
                    std::getline(in, line);
                    std::stringstream ss(line);
                    ss >> entity_dim >> entity_tag >> parametric >> nodes_in_block;
                }

                for (Integer jj = 0; jj < nodes_in_block; ++jj) {
                    std::getline(in, line); // node tags
                }

                for (Integer jj = 0; jj < nodes_in_block; ++jj) {
                    Coord coord;

                    std::getline(in, line); // node coords
                    std::stringstream ss(line);
                    ss >> coord.x >> coord.y >> coord.z;

                    _entities[entity_tag].push_back(static_cast<Integer>(_nodes->size()));
                    _nodes->push_back(coord);
                }
            }
        }

        if (line == "$Elements") {
            Integer num_entity_blocks = 0;
            Integer num_elements = 0;

            {
                std::getline(in, line);
                std::stringstream ss(line);
                ss >> num_entity_blocks >> num_elements;
            }

            for (Integer ii = 0; ii < num_entity_blocks; ++ii) {
                Integer entity_dim = 0;
                Integer entity_tag = 0;
                Integer element_type = 0;
                Integer elements_in_block = 0;
                {
                    std::getline(in, line);
                    std::stringstream ss(line);
                    ss >> entity_dim >> entity_tag >> element_type >> elements_in_block;
                }

                for (Integer jj = 0; jj < elements_in_block; ++jj) {
                    std::getline(in, line);

                    if (element_type == 1) {
                        // 2-node line

                        Integer element_tag = 0;
                        Integer ind1 = 0;
                        Integer ind2 = 0;

                        std::stringstream ss(line);
                        ss >> element_tag >> ind1 >> ind2;

                        std::array<Integer, 2> node_indices = {ind1 - 1, ind2 - 1};

                        constexpr auto dimension = 1; // 1d
                        _elements[static_cast<size_t>(dimension)].push_back(
                            std::make_shared<Line>(node_indices, _nodes));
                    } else if (element_type == 2) {
                        // 3-node triangle

                        Integer element_tag = 0;
                        Integer ind1 = 0;
                        Integer ind2 = 0;
                        Integer ind3 = 0;

                        std::stringstream ss(line);
                        ss >> element_tag >> ind1 >> ind2 >> ind3;

                        std::array<Integer, 3> node_indices = {ind1 - 1, ind2 - 1, ind3 - 1};

                        constexpr auto dimension = 2; // 2d
                        _elements[static_cast<size_t>(dimension)].push_back(
                            std::make_shared<Triangle>(node_indices, _nodes));
                    }
                }
            }
        }
    }

    Log::Info("Num nodes read = {}", _nodes->size());
    for (size_t ii = 0; ii < 4; ++ii) {
        Log::Info("Num elements read = {} (dimension {})", _elements.at(ii).size(), ii);
    }

    in.close();
}

void Mesh::WriteVTK(const std::filesystem::path &filename) const {
    std::ofstream out(filename);

    constexpr auto float_precision = 16;

    out << "# vtk DataFile Version 2.0" << std::endl;
    out << "Generated by Plasmatic" << std::endl;
    out << "ASCII" << std::endl;

    out << "DATASET UNSTRUCTURED_GRID" << std::endl;
    out << "POINTS " << _nodes->size() << " double" << std::endl;
    for (size_t ii = 0; ii < _nodes->size(); ++ii) {
        out << std::setprecision(float_precision) << (*_nodes)[ii].x << " ";
        out << std::setprecision(float_precision) << (*_nodes)[ii].y << " ";
        out << std::setprecision(float_precision) << (*_nodes)[ii].z << std::endl;
    }
    out << std::endl;

    Integer size_of_elements = 0;
    Integer num_elements = 0;
    for (const auto &elements : _elements) {
        for (const auto &element : elements) {
            size_of_elements += element->NumNodes() + 1;
            num_elements++;
        }
    }

    out << "CELLS " << num_elements << " " << size_of_elements << std::endl;
    for (const auto &elements : _elements) {
        for (const auto &element : elements) {
            out << element->NumNodes();
            for (Integer jj = 0; jj < element->NumNodes(); ++jj) {
                out << " " << element->GetNodeInex(jj);
            }
            out << std::endl;
        }
    }
    out << std::endl;

    out << "CELL_TYPES " << num_elements << std::endl;
    for (const auto &elements : _elements) {
        for (const auto &element : elements) {
            out << element->VTKCellType() << std::endl;
        }
    }
    out << std::endl;

    for (const auto &[data_name, values] : _scalarFields) {
        out << "SCALARS " << data_name << " double" << std::endl;
        out << "LOOKUP_TABLE default" << std::endl;
        for (const auto &value : values) {
            out << std::setprecision(float_precision) << value << std::endl;
        }
        out << std::endl;
    }

    for (const auto &[data_name, values] : _vectorFields) {
        out << "VECTORS " << data_name << " double" << std::endl;
        out << "LOOKUP_TABLE default" << std::endl;
        for (const auto &value : values) {
            out << std::setprecision(float_precision) << value[0] << " " << value[1] << " " << value[2] << std::endl;
        }
        out << std::endl;
    }

    out.close();
}

} // namespace plasmatic
